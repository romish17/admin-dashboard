import { prisma } from '../../config/database.js';
import { NotFoundError } from '../../middleware/errorHandler.js';
import { PaginationParams, paginatedResponse, getPrismaSkipTake } from '../../utils/pagination.js';
import { CreateRegistryInput, UpdateRegistryInput, RegistryQueryInput } from './registries.schema.js';

class RegistriesService {
  async findAll(userId: string, query: RegistryQueryInput, pagination: PaginationParams) {
    const where: Record<string, unknown> = { userId };

    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { keyPath: { contains: query.search, mode: 'insensitive' } },
        { valueName: { contains: query.search, mode: 'insensitive' } },
        { description: { contains: query.search, mode: 'insensitive' } },
      ];
    }

    if (query.valueType) where.valueType = query.valueType;
    if (query.categoryId) where.categoryId = query.categoryId;
    if (query.isFavorite !== undefined) where.isFavorite = query.isFavorite;

    const [entries, total] = await Promise.all([
      prisma.registryEntry.findMany({
        where,
        ...getPrismaSkipTake(pagination),
        orderBy: { [pagination.sortBy || 'createdAt']: pagination.sortOrder },
        include: {
          category: { select: { id: true, name: true, color: true } },
          tags: { include: { tag: { select: { id: true, name: true, color: true } } } },
        },
      }),
      prisma.registryEntry.count({ where }),
    ]);

    return paginatedResponse(
      entries.map((e) => ({ ...e, tags: e.tags.map((t) => t.tag) })),
      total,
      pagination
    );
  }

  async findById(id: string, userId: string) {
    const entry = await prisma.registryEntry.findFirst({
      where: { id, userId },
      include: {
        category: true,
        tags: { include: { tag: true } },
        linkedProcedures: { include: { procedure: { select: { id: true, title: true } } } },
      },
    });

    if (!entry) throw new NotFoundError('Registry entry', id);

    return {
      ...entry,
      tags: entry.tags.map((t) => t.tag),
      linkedProcedures: entry.linkedProcedures.map((p) => p.procedure),
    };
  }

  async create(userId: string, data: CreateRegistryInput) {
    const { tagIds, ...entryData } = data;

    const entry = await prisma.registryEntry.create({
      data: {
        ...entryData,
        userId,
        tags: tagIds?.length ? { create: tagIds.map((tagId) => ({ tagId })) } : undefined,
      },
      include: {
        category: true,
        tags: { include: { tag: true } },
      },
    });

    return { ...entry, tags: entry.tags.map((t) => t.tag) };
  }

  async update(id: string, userId: string, data: UpdateRegistryInput) {
    await this.findById(id, userId);
    const { tagIds, ...entryData } = data;

    const entry = await prisma.$transaction(async (tx) => {
      if (tagIds !== undefined) {
        await tx.registryEntryTag.deleteMany({ where: { registryEntryId: id } });
        if (tagIds.length > 0) {
          await tx.registryEntryTag.createMany({
            data: tagIds.map((tagId) => ({ registryEntryId: id, tagId })),
          });
        }
      }

      return tx.registryEntry.update({
        where: { id },
        data: entryData,
        include: { category: true, tags: { include: { tag: true } } },
      });
    });

    return { ...entry, tags: entry.tags.map((t) => t.tag) };
  }

  async delete(id: string, userId: string) {
    await this.findById(id, userId);
    await prisma.registryEntry.delete({ where: { id } });
    return { success: true };
  }

  async toggleFavorite(id: string, userId: string) {
    const entry = await this.findById(id, userId);
    const updated = await prisma.registryEntry.update({
      where: { id },
      data: { isFavorite: !entry.isFavorite },
    });
    return { isFavorite: updated.isFavorite };
  }

  async exportToReg(ids: string[], userId: string): Promise<string> {
    const entries = await prisma.registryEntry.findMany({
      where: { id: { in: ids }, userId },
    });

    if (entries.length === 0) {
      throw new NotFoundError('Registry entries');
    }

    let regContent = 'Windows Registry Editor Version 5.00\n\n';
    regContent += `; Generated by AdminDashboard on ${new Date().toISOString()}\n`;
    regContent += `; Total entries: ${entries.length}\n\n`;

    // Group entries by key path
    const groupedByPath = entries.reduce<Record<string, typeof entries>>((acc, entry) => {
      if (!acc[entry.keyPath]) acc[entry.keyPath] = [];
      acc[entry.keyPath].push(entry);
      return acc;
    }, {});

    for (const [keyPath, pathEntries] of Object.entries(groupedByPath)) {
      regContent += `[${keyPath}]\n`;

      for (const entry of pathEntries) {
        const formattedValue = this.formatRegValue(entry.valueData, entry.valueType);
        regContent += `"${entry.valueName}"=${formattedValue}\n`;
      }

      regContent += '\n';
    }

    return regContent;
  }

  private formatRegValue(data: string, type: string): string {
    switch (type) {
      case 'REG_SZ':
        return `"${data.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
      case 'REG_DWORD':
        const dwordValue = parseInt(data, 10);
        return `dword:${dwordValue.toString(16).padStart(8, '0')}`;
      case 'REG_QWORD':
        const qwordValue = BigInt(data);
        return `qword:${qwordValue.toString(16).padStart(16, '0')}`;
      case 'REG_EXPAND_SZ':
        const hexBytes = Buffer.from(data + '\0', 'utf16le')
          .toString('hex')
          .match(/.{2}/g)
          ?.join(',');
        return `hex(2):${hexBytes}`;
      case 'REG_MULTI_SZ':
        const multiBytes = Buffer.from(data.split('\n').join('\0') + '\0\0', 'utf16le')
          .toString('hex')
          .match(/.{2}/g)
          ?.join(',');
        return `hex(7):${multiBytes}`;
      case 'REG_BINARY':
        return `hex:${data}`;
      default:
        return `"${data}"`;
    }
  }

  async search(userId: string, query: string, limit = 10) {
    const entries = await prisma.registryEntry.findMany({
      where: {
        userId,
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { keyPath: { contains: query, mode: 'insensitive' } },
          { valueName: { contains: query, mode: 'insensitive' } },
        ],
      },
      take: limit,
      select: {
        id: true,
        name: true,
        keyPath: true,
        createdAt: true,
        updatedAt: true,
        category: { select: { name: true } },
        tags: { include: { tag: { select: { name: true } } } },
      },
    });

    return entries.map((entry) => ({
      id: entry.id,
      type: 'registry' as const,
      title: entry.name,
      description: entry.keyPath,
      tags: entry.tags.map((t) => t.tag.name),
      categories: entry.category ? [entry.category.name] : [],
      createdAt: entry.createdAt,
      updatedAt: entry.updatedAt,
    }));
  }
}

export const registriesService = new RegistriesService();
